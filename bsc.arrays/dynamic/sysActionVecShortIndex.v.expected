//
// Generated by Bluespec Compiler
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module sysActionVecShortIndex(CLK,
			      RST_N);
  input  CLK;
  input  RST_N;

  // register idx
  reg [1 : 0] idx;
  wire [1 : 0] idx$D_IN;
  wire idx$EN;

  // ports of submodule fs_0
  wire [7 : 0] fs_0$D_IN;
  wire fs_0$CLR, fs_0$DEQ, fs_0$ENQ, fs_0$FULL_N;

  // ports of submodule fs_1
  wire [7 : 0] fs_1$D_IN;
  wire fs_1$CLR, fs_1$DEQ, fs_1$ENQ, fs_1$FULL_N;

  // ports of submodule fs_2
  wire [7 : 0] fs_2$D_IN;
  wire fs_2$CLR, fs_2$DEQ, fs_2$ENQ, fs_2$FULL_N;

  // ports of submodule fs_3
  wire [7 : 0] fs_3$D_IN;
  wire fs_3$CLR, fs_3$DEQ, fs_3$ENQ, fs_3$FULL_N;

  // ports of submodule fs_4
  wire [7 : 0] fs_4$D_IN;
  wire fs_4$CLR, fs_4$DEQ, fs_4$ENQ;

  // ports of submodule fs_5
  wire [7 : 0] fs_5$D_IN;
  wire fs_5$CLR, fs_5$DEQ, fs_5$ENQ;

  // rule scheduling signals
  reg WILL_FIRE_RL_r;

  // submodule fs_0
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_0(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_0$D_IN),
					      .ENQ(fs_0$ENQ),
					      .DEQ(fs_0$DEQ),
					      .CLR(fs_0$CLR),
					      .D_OUT(),
					      .FULL_N(fs_0$FULL_N),
					      .EMPTY_N());

  // submodule fs_1
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_1(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_1$D_IN),
					      .ENQ(fs_1$ENQ),
					      .DEQ(fs_1$DEQ),
					      .CLR(fs_1$CLR),
					      .D_OUT(),
					      .FULL_N(fs_1$FULL_N),
					      .EMPTY_N());

  // submodule fs_2
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_2(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_2$D_IN),
					      .ENQ(fs_2$ENQ),
					      .DEQ(fs_2$DEQ),
					      .CLR(fs_2$CLR),
					      .D_OUT(),
					      .FULL_N(fs_2$FULL_N),
					      .EMPTY_N());

  // submodule fs_3
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_3(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_3$D_IN),
					      .ENQ(fs_3$ENQ),
					      .DEQ(fs_3$DEQ),
					      .CLR(fs_3$CLR),
					      .D_OUT(),
					      .FULL_N(fs_3$FULL_N),
					      .EMPTY_N());

  // submodule fs_4
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_4(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_4$D_IN),
					      .ENQ(fs_4$ENQ),
					      .DEQ(fs_4$DEQ),
					      .CLR(fs_4$CLR),
					      .D_OUT(),
					      .FULL_N(),
					      .EMPTY_N());

  // submodule fs_5
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fs_5(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(fs_5$D_IN),
					      .ENQ(fs_5$ENQ),
					      .DEQ(fs_5$DEQ),
					      .CLR(fs_5$CLR),
					      .D_OUT(),
					      .FULL_N(),
					      .EMPTY_N());

  // rule RL_r
  always@(idx or fs_0$FULL_N or fs_1$FULL_N or fs_2$FULL_N or fs_3$FULL_N)
  begin
    case (idx)
      2'd0: WILL_FIRE_RL_r = fs_0$FULL_N;
      2'd1: WILL_FIRE_RL_r = fs_1$FULL_N;
      2'd2: WILL_FIRE_RL_r = fs_2$FULL_N;
      2'd3: WILL_FIRE_RL_r = fs_3$FULL_N;
    endcase
  end

  // register idx
  assign idx$D_IN = 2'h0 ;
  assign idx$EN = 1'b0 ;

  // submodule fs_0
  assign fs_0$D_IN = 8'd0 ;
  assign fs_0$ENQ = WILL_FIRE_RL_r && idx == 2'd0 ;
  assign fs_0$DEQ = 1'b0 ;
  assign fs_0$CLR = 1'b0 ;

  // submodule fs_1
  assign fs_1$D_IN = 8'd0 ;
  assign fs_1$ENQ = WILL_FIRE_RL_r && idx == 2'd1 ;
  assign fs_1$DEQ = 1'b0 ;
  assign fs_1$CLR = 1'b0 ;

  // submodule fs_2
  assign fs_2$D_IN = 8'd0 ;
  assign fs_2$ENQ = WILL_FIRE_RL_r && idx == 2'd2 ;
  assign fs_2$DEQ = 1'b0 ;
  assign fs_2$CLR = 1'b0 ;

  // submodule fs_3
  assign fs_3$D_IN = 8'd0 ;
  assign fs_3$ENQ = WILL_FIRE_RL_r && idx == 2'd3 ;
  assign fs_3$DEQ = 1'b0 ;
  assign fs_3$CLR = 1'b0 ;

  // submodule fs_4
  assign fs_4$D_IN = 8'h0 ;
  assign fs_4$ENQ = 1'b0 ;
  assign fs_4$DEQ = 1'b0 ;
  assign fs_4$CLR = 1'b0 ;

  // submodule fs_5
  assign fs_5$D_IN = 8'h0 ;
  assign fs_5$ENQ = 1'b0 ;
  assign fs_5$DEQ = 1'b0 ;
  assign fs_5$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        idx <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (idx$EN) idx <= `BSV_ASSIGNMENT_DELAY idx$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    idx = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // sysActionVecShortIndex

