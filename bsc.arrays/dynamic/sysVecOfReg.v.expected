//
// Generated by Bluespec Compiler
//
//
// Ports:
// Name                         I/O  size props
// RDY_write                      O     1 const
// read                           O     8
// RDY_read                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// write_idx                      I     3
// write_val                      I     8 reg
// read_idx                       I     3
// EN_write                       I     1
//
// Combinational paths from inputs to outputs:
//   read_idx -> read
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module sysVecOfReg(CLK,
		   RST_N,

		   write_idx,
		   write_val,
		   EN_write,
		   RDY_write,

		   read_idx,
		   read,
		   RDY_read);
  input  CLK;
  input  RST_N;

  // action method write
  input  [2 : 0] write_idx;
  input  [7 : 0] write_val;
  input  EN_write;
  output RDY_write;

  // value method read
  input  [2 : 0] read_idx;
  output [7 : 0] read;
  output RDY_read;

  // signals for module outputs
  reg [7 : 0] read;
  wire RDY_read, RDY_write;

  // register rg_0
  reg [7 : 0] rg_0;
  wire [7 : 0] rg_0$D_IN;
  wire rg_0$EN;

  // register rg_1
  reg [7 : 0] rg_1;
  wire [7 : 0] rg_1$D_IN;
  wire rg_1$EN;

  // register rg_2
  reg [7 : 0] rg_2;
  wire [7 : 0] rg_2$D_IN;
  wire rg_2$EN;

  // register rg_3
  reg [7 : 0] rg_3;
  wire [7 : 0] rg_3$D_IN;
  wire rg_3$EN;

  // register rg_4
  reg [7 : 0] rg_4;
  wire [7 : 0] rg_4$D_IN;
  wire rg_4$EN;

  // register rg_5
  reg [7 : 0] rg_5;
  wire [7 : 0] rg_5$D_IN;
  wire rg_5$EN;

  // register rg_6
  reg [7 : 0] rg_6;
  wire [7 : 0] rg_6$D_IN;
  wire rg_6$EN;

  // register rg_7
  reg [7 : 0] rg_7;
  wire [7 : 0] rg_7$D_IN;
  wire rg_7$EN;

  // action method write
  assign RDY_write = 1'd1 ;

  // value method read
  always@(read_idx or
	  rg_0 or rg_1 or rg_2 or rg_3 or rg_4 or rg_5 or rg_6 or rg_7)
  begin
    case (read_idx)
      3'd0: read = rg_0;
      3'd1: read = rg_1;
      3'd2: read = rg_2;
      3'd3: read = rg_3;
      3'd4: read = rg_4;
      3'd5: read = rg_5;
      3'd6: read = rg_6;
      3'd7: read = rg_7;
    endcase
  end
  assign RDY_read = 1'd1 ;

  // register rg_0
  assign rg_0$D_IN = write_val ;
  assign rg_0$EN = EN_write && write_idx == 3'd0 ;

  // register rg_1
  assign rg_1$D_IN = write_val ;
  assign rg_1$EN = EN_write && write_idx == 3'd1 ;

  // register rg_2
  assign rg_2$D_IN = write_val ;
  assign rg_2$EN = EN_write && write_idx == 3'd2 ;

  // register rg_3
  assign rg_3$D_IN = write_val ;
  assign rg_3$EN = EN_write && write_idx == 3'd3 ;

  // register rg_4
  assign rg_4$D_IN = write_val ;
  assign rg_4$EN = EN_write && write_idx == 3'd4 ;

  // register rg_5
  assign rg_5$D_IN = write_val ;
  assign rg_5$EN = EN_write && write_idx == 3'd5 ;

  // register rg_6
  assign rg_6$D_IN = write_val ;
  assign rg_6$EN = EN_write && write_idx == 3'd6 ;

  // register rg_7
  assign rg_7$D_IN = write_val ;
  assign rg_7$EN = EN_write && write_idx == 3'd7 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_0 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_3 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_4 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_5 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_6 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_7 <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (rg_0$EN) rg_0 <= `BSV_ASSIGNMENT_DELAY rg_0$D_IN;
	if (rg_1$EN) rg_1 <= `BSV_ASSIGNMENT_DELAY rg_1$D_IN;
	if (rg_2$EN) rg_2 <= `BSV_ASSIGNMENT_DELAY rg_2$D_IN;
	if (rg_3$EN) rg_3 <= `BSV_ASSIGNMENT_DELAY rg_3$D_IN;
	if (rg_4$EN) rg_4 <= `BSV_ASSIGNMENT_DELAY rg_4$D_IN;
	if (rg_5$EN) rg_5 <= `BSV_ASSIGNMENT_DELAY rg_5$D_IN;
	if (rg_6$EN) rg_6 <= `BSV_ASSIGNMENT_DELAY rg_6$D_IN;
	if (rg_7$EN) rg_7 <= `BSV_ASSIGNMENT_DELAY rg_7$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_0 = 8'hAA;
    rg_1 = 8'hAA;
    rg_2 = 8'hAA;
    rg_3 = 8'hAA;
    rg_4 = 8'hAA;
    rg_5 = 8'hAA;
    rg_6 = 8'hAA;
    rg_7 = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // sysVecOfReg

