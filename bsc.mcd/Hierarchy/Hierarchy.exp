# ----------

# One module with two absolute clocks used by independent rules and state
test_c_only_bsv    OneModule sysOneModule.c.out.expected
test_veri_only_bsv OneModule sysOneModule.v.out.expected

# This is the same as OneModule, but it puts the two domains in
# separately-synthesized submodules which are clocked_by the two clocks.
# (Note that the expected file is the same as for sysOneModule.)
test_c_only_bsv_modules \
    TwoSubmodulesClockedBy \
    {mkTwoSubmodulesClockedBy_Sub1 mkTwoSubmodulesClockedBy_Sub2} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    TwoSubmodulesClockedBy \
    {mkTwoSubmodulesClockedBy_Sub1 mkTwoSubmodulesClockedBy_Sub2} \
    sysOneModule.v.out.expected

# Like above, but puts the clockgen in a submodule, to test output clocks.
# (Note that the expected file is the same as for sysOneModule.)
test_c_only_bsv_modules \
    TwoSubmodulesClockedByOutputClock \
    {mkTwoSubmodulesClockedByOutputClock_ClkSub1 \
     mkTwoSubmodulesClockedByOutputClock_Sub1 \
     mkTwoSubmodulesClockedByOutputClock_Sub2} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    TwoSubmodulesClockedByOutputClock \
    {mkTwoSubmodulesClockedByOutputClock_ClkSub1 \
     mkTwoSubmodulesClockedByOutputClock_Sub1 \
     mkTwoSubmodulesClockedByOutputClock_Sub2} \
    sysOneModule.v.out.expected

# In this two-submodule version, instead of being clocked_by, the clocks
# are passed in as input clocks that are then used to clock the registers
# in the submodule.
test_c_only_bsv_modules \
    TwoSubmodulesInputClock \
    {mkTwoSubmodulesInputClock_Sub1 mkTwoSubmodulesInputClock_Sub2} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    TwoSubmodulesInputClock \
    {mkTwoSubmodulesInputClock_Sub1 mkTwoSubmodulesInputClock_Sub2} \
    sysOneModule.v.out.expected

# Like above, but puts the clockgen in a submodule, to test output clocks.
test_c_only_bsv_modules \
    TwoSubmodulesInputClockOutputClock \
    {mkTwoSubmodulesInputClockOutputClock_ClkSub1 \
     mkTwoSubmodulesInputClockOutputClock_Sub1 \
     mkTwoSubmodulesInputClockOutputClock_Sub2} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    TwoSubmodulesInputClockOutputClock \
    {mkTwoSubmodulesInputClockOutputClock_ClkSub1 \
     mkTwoSubmodulesInputClockOutputClock_Sub1 \
     mkTwoSubmodulesInputClockOutputClock_Sub2} \
    sysOneModule.v.out.expected

# ----------

# Similar to OneModule.bsv but creates resets along with the clocks
#test_c_veri_bsv OneModuleWithReset.bsv

# Hierarchical tests require the ability to associate input resets with
# input clocks

# ----------

# Simple output clock test
# Should have the same output as OneModule

test_c_only_bsv_modules \
    OneModuleOutputClock \
    {mkOneModuleOutputClock_Sub} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    OneModuleOutputClock \
    {mkOneModuleOutputClock_Sub} \
    sysOneModule.v.out.expected

# ----------

# Test two input clocks which are assigned the same clock
# (this also tests "clocked_by noClock")

# The expected output was generated by simulating without the synth boundary
test_c_only_bsv_modules_options \
    InputClocksSameDomain \
    {mkInputClocksSameDomain_Sub} \
    {-g mkInputClocksSameDomain_Sub} \
    sysInputClocksSameDomain.c.out.expected

# Verilog's only difference should be missing the displays at time 0
# ... except that the displays are in different always blocks in the
# separately synthesized version, so they are not guaranteed to match
# the non-synth expected file (or match other simulators).
# This is the iverilog expected output.
test_veri_only_bsv_modules_options \
    InputClocksSameDomain \
    {mkInputClocksSameDomain_Sub} \
    {-g mkInputClocksSameDomain_Sub} \
    sysInputClocksSameDomain.v.out.expected

# ----------

# Tests for substitutions of input and output clocks

# The output should be the same as sysOneModule, but it turns out that
# for Bluesim the order of displays on coincident edges is different,
# so we use a different expected file (which should only differ in
# that way).  Verilog (at least iverilog) works on the same expected file

# Test an input and output clock in the same domain
test_c_only_bsv_modules \
    OneModule_InputOutputClock \
    {mkOneModule_InputOutputClock_Sub} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    OneModule_InputOutputClock \
    {mkOneModule_InputOutputClock_Sub} \
    sysOneModule.v.out.expected

# Test an input clock that goes two levels down and then comes back up
# two levels
test_c_only_bsv_modules \
    OneModule_InputOutputClock2 \
    {mkOneModule_InputOutputClock2_Sub1 mkOneModule_InputOutputClock2_Sub2} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    OneModule_InputOutputClock2 \
    {mkOneModule_InputOutputClock2_Sub1 mkOneModule_InputOutputClock2_Sub2} \
    sysOneModule.v.out.expected

# Test an input clock which comes out as an output which then goes into
# another module (and then out again)
test_c_only_bsv_modules \
    OneModule_InputOutputClock3 \
    {mkOneModule_InputOutputClock3_Sub} \
    sysOneModule.c.out.expected
test_veri_only_bsv_modules \
    OneModule_InputOutputClock3 \
    {mkOneModule_InputOutputClock3_Sub} \
    sysOneModule.v.out.expected

# ----------

# Test noClock
# (Same expected file is used in all cases)
# (Verilog output differs by missing the display at time 0)

# Parent passes noClock to a child
# XXX This fails to compile until we change noClock to have a gate of 1
if { 0 } {
test_c_only_bsv_modules \
    NoClock_Input \
    {mkNoClock_Input_Sub} \
    sysNoClock.out.expected
test_veri_only_bsv_modules \
    NoClock_Input \
    {mkNoClock_Input_Sub} \
    sysNoClock.v.out.expected
}
# XXX So we do this for now
compile_verilog_fail NoClock_Input.bsv
compile_object_fail  NoClock_Input.bsv
# But it should work with gate ports
set gate_options {-hack-gate-clock-inputs}
test_c_only_bsv_modules_options \
    NoClock_Input \
    {mkNoClock_Input_Sub} \
    $gate_options \
    sysNoClock.out.expected
test_veri_only_bsv_modules_options \
    NoClock_Input \
    {mkNoClock_Input_Sub} \
    $gate_options \
    sysNoClock.v.out.expected

# Parent passes noClock to a child which passes it back to the parent
# (This test requires that the input clock have a gate port, since noClock
# has a gate of 0.)
set gate_options {-hack-gate-clock-inputs}
test_c_only_bsv_modules_options \
    NoClock_InputOutput \
    {mkNoClock_InputOutput_Sub} \
    $gate_options \
    sysNoClock.out.expected
# Verilog test is fine
test_veri_only_bsv_modules_options \
    NoClock_InputOutput \
    {mkNoClock_InputOutput_Sub} \
    $gate_options \
    sysNoClock.v.out.expected

# Parent receives noClock from a child
test_c_only_bsv_modules \
    NoClock_Output \
    {mkNoClock_Output_Sub} \
    sysNoClock.out.expected
test_veri_only_bsv_modules \
    NoClock_Output \
    {mkNoClock_Output_Sub} \
    sysNoClock.v.out.expected

# ----------

